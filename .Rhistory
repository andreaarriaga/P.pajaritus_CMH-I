library(lme4)
library(ggplot2)
## Modelo correcto: incluye la poblacion y el año como efecto aleatorio
mod1 <- lmer(D ~ degradacion + (1|P) + (1|A) + L, data = datos)
library(lme4)
library(ggplot2)
# setwd("/home/andrea/Documentos/ciencia_replicable/P.pajaritus_CMH-I")
datos <- read.csv("Datos_tarea4.csv", header = TRUE)
str(datos)
## Modelo correcto: incluye la poblacion y el año como efecto aleatorio
mod1 <- lmer(D ~ H1 + H2 + H3 + H4 + H5 + (1|P) + (1|A) + L, data = datos)
# mod1
# summary(mod1)
# prueba con PCA
Hpca <- princomp(datos[,c("H1", "H2", "H3", "H4", "H5")])
# Hpca
summary(Hpca)
# str(Hpca)
## extrayendo los scrores del promer componente principal para hacerlo una nueva variable que agrupa todas las H
datos$degradacion <- Hpca$scores[,1]
head(datos)
## preparacion de los datos para hacer los graficos
datos$P <- as.factor(datos$P)
datos$A <- as.factor(datos$A)
## calculando el promedio por P
# prom <- aggregate(D ~ P, FUN = mean, data = datos)
## grafico con los scores del PC1 (degradacion) como variable predictora
ggplot(datos, aes(degradacion, D )) +
geom_point(alpha = 0.4,  show.legend = FALSE) +
geom_smooth(show.legend = FALSE) +
theme_bw()
## dividido por poblacion
ggplot(datos, aes(D, degradacion, color = P)) +
geom_point(alpha = 0.5,  show.legend = FALSE) +
geom_smooth(method = "lm", show.legend = FALSE) +
theme_bw()
## Modelo correcto: incluye la poblacion y el año como efecto aleatorio
mod2 <- lmer(D ~ degradacion + (1|P) + (1|A) + L, data = datos)
mod2
summary(mod2)
## Modelo correcto: incluye la poblacion y el año como efecto aleatorio
mod1 <- lmer(D ~ H1 + H2 + H3 + H4 + H5 + (1|P) + (1|A) + L, data = datos)
mod2
summary(mod2)
## Modelo correcto: incluye la poblacion y el año como efecto aleatorio
mod1 <- lmer(D ~ degradacion + (1|P) + (1|A) + L, data = datos)
mod1
summary(mod1)
## Modelo correcto: incluye la poblacion y el año como efecto aleatorio
mod2 <- lmer(D ~ H1 + H2 + H3 + H4 + H5 + (1|P) + (1|A) + L, data = datos)
mod2
summary(mod2)
## dividido por poblacion
ggplot(datos, aes(D, degradacion, color = A)) +
geom_point(alpha = 0.5,  show.legend = FALSE) +
geom_smooth(method = "lm", show.legend = FALSE) +
theme_bw()
## dividido por poblacion
ggplot(datos, aes(D, degradacion, color = P)) +
geom_point(alpha = 0.5,  show.legend = FALSE) +
geom_smooth(method = "lm", show.legend = FALSE) +
theme_bw()
## dividido por poblacion
ggplot(datos, aes(D, degradacion, color = P)) +
geom_point(alpha = 0.5,  show.legend = FALSE) +
geom_smooth(method = "lm", show.legend = FALSE) +
theme_bw()
summ(mod1)
library(jtools)
install.packages(jtools)
install.packages("jtools")
library(jtools)
library(jtools)
summ(mod1)
?geom_smooth()
geom_smooth
## preparacion de los datos para hacer los graficos
datos$P <- as.factor(datos$P)
datos$A <- as.factor(datos$A)
## calculando el promedio por P
# prom <- aggregate(D ~ P, FUN = mean, data = datos)
## grafico con los scores del PC1 (degradacion) como variable predictora
ggplot(datos, aes(degradacion, D )) +
geom_point(alpha = 0.4,  show.legend = FALSE) +
geom_smooth(show.legend = FALSE) +
theme_bw()
?lmer()
## Modelo correcto: incluye la poblacion y el año como efecto aleatorio
mod1 <- glmer(D ~ degradacion + (1|P) + (1|A) + L, data = datos, family = "poisson")
